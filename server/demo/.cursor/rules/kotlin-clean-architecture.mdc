---
alwaysApply: true
description: Kotlin Spring Boot Clean Architecture 구현 패턴 및 규칙
---

# Kotlin Clean Architecture 구현 가이드

이 프로젝트는 Domain-Driven Design (DDD) 패턴과 함께 Clean Architecture 원칙을 따릅니다. 일관되고 유지보수 가능한 코드를 위해 다음 규칙을 따르세요.

## 프로젝트 구조

```
src/main/kotlin/com/example/demo/
├── domain/                    # 도메인 레이어 (핵심 비즈니스 로직)
│   ├── common/
│   │   └── valueobject/       # 공통 값 객체
│   ├── user/
│   │   ├── model/            # 사용자 도메인 모델
│   │   └── valueobject/      # 사용자 전용 값 객체
│   └── [other-domains]/
├── application/              # 애플리케이션 레이어 (유스케이스)
├── infrastructure/           # 인프라스트럭처 레이어 (외부 관심사)
└── interface/               # 인터페이스 레이어 (컨트롤러, DTO)
```

## 도메인 레이어 구현

### 값 객체 (Value Objects)
- 원시 타입을 래핑하는 타입 안전한 래퍼를 위해 `@JvmInline value class` 사용
- `require()` 문을 사용하여 생성자에서 검증 구현
- companion object 팩토리 메서드 제공 (`of()`, `safeOf()`)
- 비교 연산자와 유틸리티 메서드 포함

예시:
```kotlin
@JvmInline
value class Money(val amount: BigDecimal) {
    init {
        require(amount >= BigDecimal.ZERO) { "Money amount cannot be negative" }
    }
    
    operator fun plus(other: Money): Money = Money(amount.add(other.amount))
    
    companion object {
        fun of(value: BigDecimal) = Money(value)
        fun safeOf(value: BigDecimal?) = value?.let { Money(it) }
    }
}
```

### 도메인 모델
- 불변 도메인 엔티티를 위해 `data class` 사용
- 도메인 모델 내부에 비즈니스 로직 메서드 포함
- companion object에서 팩토리 메서드 제공
- 비즈니스 의도를 표현하는 의미 있는 메서드명 사용

예시:
```kotlin
data class User(
    val id: UserId,
    val email: Email,
    val membershipLevel: MembershipLevel,
    val isNewCustomer: Boolean,
    val createdAt: LocalDateTime
) {
    fun isEligibleForPromotion(requiredLevel: MembershipLevel?): Boolean {
        return requiredLevel?.let { targetLevel ->
            membershipLevel.isHigherThanOrEqualTo(targetLevel)
        } ?: true
    }
    
    companion object {
        fun createNewUser(id: UserId, email: Email): User {
            return User(
                id = id,
                email = email,
                membershipLevel = MembershipLevel.NEW,
                isNewCustomer = true,
                createdAt = LocalDateTime.now()
            )
        }
    }
}
```

### 열거형 (Enums)
- 비즈니스 의미를 가진 고정된 값 집합에 열거형 사용
- 우선순위 기반 비교 메서드 포함
- 비즈니스 로직을 위한 유틸리티 메서드 제공
- 표시명을 반환하도록 `toString()` 오버라이드

예시:
```kotlin
enum class MembershipLevel(
    val priority: Int,
    val displayName: String,
    val description: String
) {
    NEW(1, "신규 회원", "가입한 지 30일 이내의 신규 회원"),
    REGULAR(2, "일반 회원", "기본 회원 등급"),
    VIP(3, "VIP 회원", "높은 구매 실적을 가진 우수 회원"),
    PREMIUM(4, "프리미엄 회원", "최고 등급의 특별 회원");
    
    fun isHigherThan(other: MembershipLevel): Boolean = this.priority > other.priority
    
    override fun toString(): String = displayName
}
```

## 테스트 규칙

### 테스트 구조
- 읽기 쉬운 테스트 구조를 위해 `FunSpec`과 함께 Kotest 사용
- 관련 테스트를 `context()` 블록으로 그룹화
- 시나리오를 설명하는 설명적인 테스트명 사용
- 테스트 주석에서 Given-When-Then 패턴 따르기

예시:
```kotlin
class UserTest : FunSpec({
    context("프로모션 자격 검증") {
        test("VIP 회원이 일반 회원 프로모션에 자격이 있어야 한다") {
            // Given
            val vipUser = User.createExistingUser(
                id = UserId(1L),
                email = Email("vip@example.com"),
                membershipLevel = MembershipLevel.VIP,
                isNewCustomer = false,
                createdAt = LocalDateTime.now()
            )
            
            // When
            val isEligible = vipUser.isEligibleForPromotion(MembershipLevel.REGULAR)
            
            // Then
            isEligible shouldBe true
        }
    }
})
```

### 테스트 커버리지
- 모든 public 메서드와 프로퍼티 테스트
- 경계값 테스트 포함
- `shouldThrow`로 예외 시나리오 테스트
- 팩토리 메서드와 companion object 유틸리티 테스트
- 비즈니스 로직 정확성 검증

### 테스트 Import
도메인 테스트를 위해 항상 다음 import 포함:
```kotlin
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.assertions.throwables.shouldThrow
```

## 코드 품질 표준

### 검증
- 생성자에서 입력 검증을 위해 `require()` 사용
- 의미 있는 오류 메시지 제공
- 도메인 경계에서 비즈니스 규칙 검증
- 선택적 생성을 위해 `safeOf()` 메서드 사용

### 명명 규칙
- 비즈니스 의도를 표현하는 설명적인 이름 사용
- 기술적 용어보다 비즈니스 용어 선호
- 적절한 경우 비즈니스 개념에 한국어 사용
- Kotlin 명명 규칙 따르기 (camelCase)

### 문서화
- public API에 대해 KDoc 주석 포함
- 비즈니스 규칙과 제약사항 설명
- 복잡한 메서드에서 사용 예시 제공
- companion object 팩토리 메서드 문서화

### 오류 처리
- 다양한 오류 시나리오에 대해 특정 예외 타입 사용
- 비즈니스 사용자를 위해 한국어로 명확한 오류 메시지 제공
- 오류 메시지에 컨텍스트 정보 포함
- 검증 오류에 대해 `IllegalArgumentException` 사용

## 구현 순서

1. **도메인 레이어 우선**: 값 객체부터 시작한 후 도메인 모델
2. **구현과 함께 테스트**: 구현과 함께 테스트 작성
3. **애플리케이션 레이어**: 도메인이 완료된 후 유스케이스 구현
4. **인프라스트럭처 레이어**: 외부 관심사는 마지막에 추가
5. **인터페이스 레이어**: 컨트롤러와 DTO는 마지막에 생성

## 파일 구성

- 파일당 하나의 클래스
- 관련 클래스를 패키지로 그룹화
- 도메인 개념을 반영하는 의미 있는 패키지명 사용
- 테스트를 해당 테스트 패키지에 배치
- 테스트 디렉토리에서 동일한 패키지 구조 따르기

이 접근법은 Clean Architecture 원칙을 따르는 유지보수 가능하고 테스트 가능하며 비즈니스 중심의 코드를 보장합니다.