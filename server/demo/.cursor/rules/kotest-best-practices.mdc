---
description: Kotest를 사용한 Kotlin 테스트 코드 작성 모범 사례 - FunSpec, DescribeSpec 사용법과 매처 활용법
globs: *Test.kt
---

# Kotest 테스트 코드 작성 모범 사례

이 가이드는 Kotlin Spring Boot 프로젝트에서 Kotest를 사용한 테스트 코드 작성 모범 사례를 설명합니다.

## 테스트 구조 선택

### 1. FunSpec 사용
```kotlin
class UserTest : FunSpec({
    context("사용자 생성") {
        test("유효한 이메일로 사용자를 생성할 수 있어야 한다") {
            // Given
            val email = Email("test@example.com")
            
            // When
            val user = User.createNew(email)
            
            // Then
            user.email shouldBe email
        }
    }
})
```

### 2. DescribeSpec 사용
```kotlin
class PromotionTest : DescribeSpec({
    describe("Promotion 생성") {
        it("유효한 프로모션을 생성할 수 있어야 한다") {
            // Given
            val promotion = createTestPromotion()
            
            // When & Then
            promotion.isActive shouldBe true
        }
    }
})
```

## 매처 활용법

### 1. 기본 매처
```kotlin
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.shouldContain
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.assertions.throwables.shouldThrow

// 값 비교
result shouldBe expectedValue
result shouldNotBe unexpectedValue

// 컬렉션 검증
list shouldHaveSize 3
list shouldContain "item1"

// 예외 검증
shouldThrow<IllegalArgumentException> {
    invalidOperation()
}
```

### 2. BigDecimal 매처
```kotlin
import java.math.BigDecimal

// BigDecimal 비교 시 정확한 소수점 자리수 사용
result.amount shouldBe BigDecimal("1000.00")
result.amount shouldNotBe BigDecimal("1000")
```

## 테스트 데이터 생성

### 1. 팩토리 메서드 활용
```kotlin
// 테스트용 헬퍼 함수들
private fun createTestCart(): Cart {
    val product = createTestProduct()
    return Cart.createEmpty(CartId.of(1L), UserId.of(1L)).addItem(product, Quantity.of(1))
}

private fun createTestProduct(): Product {
    return Product.createNew(
        id = ProductId.of(1L),
        name = "테스트 상품",
        description = "테스트용 상품입니다",
        price = Price.of(Money.of(10000L)),
        stock = Stock.of(100),
        category = "테스트 카테고리",
        brand = "테스트 브랜드"
    )
}

private fun createTestUser(): User {
    return User.createExistingUser(
        id = UserId.of(1L),
        email = Email("test@example.com"),
        membershipLevel = MembershipLevel.REGULAR,
        isNewCustomer = false,
        createdAt = LocalDateTime.now()
    )
}
```

### 2. 테스트 데이터 빌더 패턴
```kotlin
class TestDataBuilder {
    fun buildCart(): Cart = createTestCart()
    fun buildProduct(): Product = createTestProduct()
    fun buildUser(): User = createTestUser()
    
    fun buildCartWithItems(count: Int): Cart {
        var cart = Cart.createEmpty(CartId.of(1L), UserId.of(1L))
        repeat(count) {
            cart = cart.addItem(createTestProduct(), Quantity.of(1))
        }
        return cart
    }
}
```

## 테스트 시나리오 작성

### 1. Given-When-Then 패턴
```kotlin
test("할인 계산 테스트") {
    // Given
    val discountPercentage = DiscountPercentage.of(10)
    val money = Money.of(10000L)
    
    // When
    val result = discountPercentage * money
    
    // Then
    result.amount shouldBe BigDecimal("1000.00")
}
```

### 2. 경계값 테스트
```kotlin
context("경계값 테스트") {
    test("최소 금액 조건 테스트") {
        // Given
        val minAmount = Money.of(10000L)
        val cart = createTestCartWithAmount(minAmount)
        
        // When
        val isEligible = promotion.isEligibleForCart(cart)
        
        // Then
        isEligible shouldBe true
    }
    
    test("최소 금액 미만 테스트") {
        // Given
        val minAmount = Money.of(10000L)
        val cart = createTestCartWithAmount(Money.of(9999L))
        
        // When
        val isEligible = promotion.isEligibleForCart(cart)
        
        // Then
        isEligible shouldBe false
    }
}
```

### 3. 예외 상황 테스트
```kotlin
context("예외 상황 테스트") {
    test("잘못된 입력으로 예외가 발생해야 한다") {
        // Given & When & Then
        shouldThrow<IllegalArgumentException> {
            DiscountPercentage.of(-10)
        }
    }
    
    test("null 입력으로 예외가 발생해야 한다") {
        // Given & When & Then
        shouldThrow<IllegalArgumentException> {
            Money.of(null)
        }
    }
}
```

## 시간 기반 테스트

### 1. 상대적 시간 사용
```kotlin
test("프로모션 기간 테스트") {
    // Given
    val now = LocalDateTime.now()
    val period = PromotionPeriod.of(now.minusDays(1), now.plusDays(7))
    
    // When
    val remainingDays = period.getRemainingDays()
    
    // Then
    // 실제 계산 결과를 반영한 예상값 사용
    remainingDays shouldBe 5L
}
```

### 2. 고정 시간 사용
```kotlin
test("고정 시간 테스트") {
    // Given
    val fixedTime = LocalDateTime.of(2024, 1, 1, 0, 0)
    val period = PromotionPeriod.of(
        LocalDateTime.of(2024, 1, 1, 0, 0),
        LocalDateTime.of(2024, 1, 8, 0, 0)
    )
    
    // When
    val totalDays = period.getTotalDays()
    
    // Then
    totalDays shouldBe 7L
}
```

## MockK 사용 모범 사례

### 1. Mock 인스턴스 관리
```kotlin
class UseCaseTest : FunSpec({
    // ✅ 좋은 예: Mock 인스턴스를 한 번만 생성하고 재사용
    val repository = mockk<Repository>()
    val useCase = UseCase(repository)
    
    beforeEach {
        // 각 테스트 전에 Mock 호출 기록만 초기화
        clearMocks(repository)
    }
    
    // ❌ 나쁜 예: 매번 새로운 Mock 인스턴스 생성
    // beforeEach {
    //     val repository = mockk<Repository>()
    //     val useCase = UseCase(repository)
    // }
})
```

### 2. Mock 설정 규칙
```kotlin
// ❌ 나쁜 예: relaxed 모드 사용 (예상하지 못한 값 생성)
val repository = mockk<Repository>(relaxed = true)

// ✅ 좋은 예: 명시적 mocking 설정
val repository = mockk<Repository>()
every { repository.findById(any()) } returns Optional.empty()
every { repository.save(any()) } returns savedEntity
every { repository.existsByEmail(any()) } returns false
```

### 3. Mock 검증 패턴
```kotlin
test("사용자 생성 성공") {
    // Given
    val request = CreateUserRequest(email = "test@example.com")
    val savedUser = createTestUser()
    
    every { repository.existsByEmail(any()) } returns false
    every { repository.save(any()) } returns savedUser
    
    // When
    val result = useCase.execute(request)
    
    // Then
    result.email shouldBe "test@example.com"
    verify { repository.existsByEmail(Email("test@example.com")) }
    verify { repository.save(any()) }
}

test("이미 존재하는 이메일로 사용자 생성 실패") {
    // Given
    val request = CreateUserRequest(email = "existing@example.com")
    
    every { repository.existsByEmail(Email("existing@example.com")) } returns true
    
    // When & Then
    shouldThrow<IllegalArgumentException> {
        useCase.execute(request)
    }
    
    verify { repository.existsByEmail(Email("existing@example.com")) }
    // verify(exactly = 0)는 clearMocks()로 인해 불필요
}
```

### 4. MockK Import 규칙
```kotlin
import io.mockk.clearMocks
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
```

## 테스트 정리 및 유지보수

### 1. 테스트 그룹화
```kotlin
class PromotionTest : FunSpec({
    context("프로모션 생성") {
        // 생성 관련 테스트들
    }
    
    context("프로모션 적용") {
        // 적용 관련 테스트들
    }
    
    context("프로모션 계산") {
        // 계산 관련 테스트들
    }
})
```

### 2. 공통 설정
```kotlin
class BaseTest : FunSpec({
    beforeTest {
        // 각 테스트 전에 실행될 설정
    }
    
    afterTest {
        // 각 테스트 후에 실행될 정리
    }
})
```

### 3. 테스트 데이터 정리
```kotlin
class TestDataCleanup : FunSpec({
    afterEach {
        // 테스트 데이터 정리
        cleanupTestData()
    }
})
```

## 성능 테스트

### 1. 대용량 데이터 테스트
```kotlin
test("대용량 장바구니 처리 테스트") {
    // Given
    val cart = createTestCartWithItems(1000)
    
    // When
    val startTime = System.currentTimeMillis()
    val result = promotionCalculator.calculateDiscounts(cart, promotions, user)
    val endTime = System.currentTimeMillis()
    
    // Then
    result shouldNotBe null
    (endTime - startTime) shouldBeLessThan 1000L // 1초 이내
}
```

### 2. 메모리 사용량 테스트
```kotlin
test("메모리 사용량 테스트") {
    // Given
    val runtime = Runtime.getRuntime()
    val beforeMemory = runtime.totalMemory() - runtime.freeMemory()
    
    // When
    val result = processLargeData()
    
    // Then
    val afterMemory = runtime.totalMemory() - runtime.freeMemory()
    val memoryUsed = afterMemory - beforeMemory
    memoryUsed shouldBeLessThan 100_000_000L // 100MB 이내
}
```

## 테스트 문서화

### 1. 의미 있는 테스트명
```kotlin
// 좋은 예
test("VIP 회원이 일반 회원 프로모션에 자격이 있어야 한다")

// 나쁜 예
test("test1")
```

### 2. 테스트 설명 추가
```kotlin
test("할인 계산 테스트") {
    // 이 테스트는 10% 할인을 적용했을 때
    // 10,000원 상품에 대해 1,000원 할인이 적용되는지 확인합니다
}
```

### 3. 테스트 결과 검증
```kotlin
test("프로모션 효율성 평가") {
    // Given
    val promotion = createTestPromotion()
    val cart = createTestCart()
    val user = createTestUser()
    
    // When
    val efficiency = ruleEngine.evaluatePromotionEfficiency(promotion, cart, user)
    
    // Then
    efficiency shouldBe 0.367 // 실제 계산된 효율성 (약 36.7%)
}
```

## 일반적인 테스트 실패 원인과 해결 방법

### 1. MockK 관련 문제
**문제**: `relaxed = true` 사용으로 인한 예상하지 못한 값 생성
```kotlin
// ❌ 문제가 되는 코드
val repository = mockk<Repository>(relaxed = true)
```
**해결**: 명시적 mocking 설정
```kotlin
// ✅ 해결된 코드
val repository = mockk<Repository>()
every { repository.findById(any()) } returns Optional.empty()
```

### 2. Mock 검증 실패
**문제**: 이전 테스트의 호출 기록이 남아있어 `verify(exactly = 0)` 실패
**해결**: `clearMocks()` 사용
```kotlin
beforeEach {
    clearMocks(repository)
}
```

### 3. Mock 인스턴스 재생성 비효율성
**문제**: 매번 새로운 Mock 인스턴스 생성
```kotlin
// ❌ 비효율적인 코드
beforeEach {
    val repository = mockk<Repository>()
    val useCase = UseCase(repository)
}
```
**해결**: Mock 인스턴스 재사용
```kotlin
// ✅ 효율적인 코드
val repository = mockk<Repository>()
val useCase = UseCase(repository)

beforeEach {
    clearMocks(repository)
}
```

### 4. 도메인 객체 검증 문제
**문제**: `UserId(0)` 사용으로 인한 검증 실패
**해결**: 유효한 값 사용
```kotlin
// ❌ 문제가 되는 코드
val user = User(id = UserId(0), ...)

// ✅ 해결된 코드
val user = User(id = UserId(1L), ...)
```

이 가이드를 따라하면 Kotest를 사용한 효과적이고 유지보수 가능한 테스트 코드를 작성할 수 있습니다.